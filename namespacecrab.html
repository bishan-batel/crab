<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>crab: crab Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">crab<span id="projectnumber">&#160;2.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacecrab.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">crab Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:any" id="r_any"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1any.html">any</a></td></tr>
<tr class="memitem:boxed" id="r_boxed"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1boxed.html">boxed</a></td></tr>
<tr class="memitem:mem" id="r_mem"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1mem.html">mem</a></td></tr>
<tr class="memitem:ops" id="r_ops"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1ops.html">ops</a></td></tr>
<tr class="memdesc:namespacecrab_1_1ops"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespacecrab_1_1ops.html" title="The crab::ops namespace contains type traits &amp; helpers related to operators and operator overloads.">crab::ops</a> namespace contains type traits &amp; helpers related to operators and operator overloads. <br /></td></tr>
<tr class="memitem:rc" id="r_rc"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1rc.html">rc</a></td></tr>
<tr class="memitem:term" id="r_term"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrab_1_1term.html">term</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:cases" id="r_cases"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrab_1_1cases.html">cases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for easily creating a Visitor instance when using std::visit and alike.  <a href="structcrab_1_1cases.html#details">More...</a><br /></td></tr>
<tr class="memitem:Err" id="r_Err"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrab_1_1Err.html">Err</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper / tagged type over a value to be given to Result&lt;T,E&gt;(Err)'s constructor.  <a href="structcrab_1_1Err.html#details">More...</a><br /></td></tr>
<tr class="memitem:Error" id="r_Error"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrab_1_1Error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base error type for use with <a class="el" href="classcrab_1_1result_1_1Result.html">Result&lt;T, E&gt;</a>  <a href="classcrab_1_1Error.html#details">More...</a><br /></td></tr>
<tr class="memitem:Ok" id="r_Ok"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrab_1_1Ok.html">Ok</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper over a value to be given to Result&lt;T,E&gt;(Ok)'s constructor.  <a href="structcrab_1_1Ok.html#details">More...</a><br /></td></tr>
<tr class="memitem:unit" id="r_unit"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrab_1_1unit.html">unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monostate type, all instances of 'unit' are indistinguishable, note that this type will never be '0' sized, unless being used as a field with [[no_unique_address]].  <a href="structcrab_1_1unit.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:into_5Fhash_5Fcode" id="r_into_5Fhash_5Fcode"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptcrab_1_1into__hash__code.html">into_hash_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any type that can be converted to a hash_code (usize) <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a464db68fc2d1e4ca61815793726f7674" id="r_a464db68fc2d1e4ca61815793726f7674"><td class="memTemplParams" colspan="2"><a id="a464db68fc2d1e4ca61815793726f7674" name="a464db68fc2d1e4ca61815793726f7674"></a>
template&lt;typename Key, typename Value, typename Hash = std::hash&lt;Key&gt;, typename Predicate = std::equal_to&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a464db68fc2d1e4ca61815793726f7674 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Dictionary</b> = std::unordered_map&lt;Key, Value, Hash, Predicate&gt;</td></tr>
<tr class="memdesc:a464db68fc2d1e4ca61815793726f7674"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Alias) Unordered key-value collection <br /></td></tr>
<tr class="memitem:a65986f529218d4d0214eba34518d5d2a" id="r_a65986f529218d4d0214eba34518d5d2a"><td class="memTemplParams" colspan="2"><a id="a65986f529218d4d0214eba34518d5d2a" name="a65986f529218d4d0214eba34518d5d2a"></a>
template&lt;typename T, typename Hash = std::hash&lt;T&gt;, typename Predicate = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a65986f529218d4d0214eba34518d5d2a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Set</b> = std::unordered_set&lt;T, Hash, Predicate&gt;</td></tr>
<tr class="memdesc:a65986f529218d4d0214eba34518d5d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Alias) Unordered set of elements <br /></td></tr>
<tr class="memitem:a39d498ff8b991cad225fa74cdc8b2aea" id="r_a39d498ff8b991cad225fa74cdc8b2aea"><td class="memTemplParams" colspan="2"><a id="a39d498ff8b991cad225fa74cdc8b2aea" name="a39d498ff8b991cad225fa74cdc8b2aea"></a>
template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a39d498ff8b991cad225fa74cdc8b2aea template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Tuple</b> = std::tuple&lt;Types...&gt;</td></tr>
<tr class="memdesc:a39d498ff8b991cad225fa74cdc8b2aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Alias) std::tuple&lt;T...&gt; alias. <br /></td></tr>
<tr class="memitem:aaa3ba808af5950c7b469d103b5bcbd12" id="r_aaa3ba808af5950c7b469d103b5bcbd12"><td class="memTemplParams" colspan="2"><a id="aaa3ba808af5950c7b469d103b5bcbd12" name="aaa3ba808af5950c7b469d103b5bcbd12"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:aaa3ba808af5950c7b469d103b5bcbd12 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Vec</b> = std::vector&lt;T&gt;</td></tr>
<tr class="memdesc:aaa3ba808af5950c7b469d103b5bcbd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Alias) Heap allocated, dynamically sized list <br /></td></tr>
<tr class="memitem:af2eac98f50d89da93b0e8d20245479de" id="r_af2eac98f50d89da93b0e8d20245479de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2eac98f50d89da93b0e8d20245479de">SourceLocation</a> = std::source_location</td></tr>
<tr class="memitem:a446b4e5f093d488ef0d55e43c0736f51" id="r_a446b4e5f093d488ef0d55e43c0736f51"><td class="memTemplParams" colspan="2">template&lt;typename F = void()&gt; </td></tr>
<tr class="memitem:a446b4e5f093d488ef0d55e43c0736f51 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a446b4e5f093d488ef0d55e43c0736f51">Func</a> = std::function&lt;F&gt;</td></tr>
<tr class="memitem:a65ead1c2bd0728e07b20e8b6c843b0aa" id="r_a65ead1c2bd0728e07b20e8b6c843b0aa"><td class="memItemLeft" align="right" valign="top"><a id="a65ead1c2bd0728e07b20e8b6c843b0aa" name="a65ead1c2bd0728e07b20e8b6c843b0aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>hash_code</b> = num::usize</td></tr>
<tr class="memdesc:a65ead1c2bd0728e07b20e8b6c843b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash code type. <br /></td></tr>
<tr class="memitem:a4e223e01b4ee36b5c7a21161cd15b688" id="r_a4e223e01b4ee36b5c7a21161cd15b688"><td class="memTemplParams" colspan="2"><a id="a4e223e01b4ee36b5c7a21161cd15b688" name="a4e223e01b4ee36b5c7a21161cd15b688"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a4e223e01b4ee36b5c7a21161cd15b688 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Hasher</b> = std::hash&lt;T&gt;</td></tr>
<tr class="memitem:a35750fd8bc2ddb9242180f4969595af2" id="r_a35750fd8bc2ddb9242180f4969595af2"><td class="memTemplParams" colspan="2"><a id="a35750fd8bc2ddb9242180f4969595af2" name="a35750fd8bc2ddb9242180f4969595af2"></a>
template&lt;typename A, typename B&gt; </td></tr>
<tr class="memitem:a35750fd8bc2ddb9242180f4969595af2 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Pair</b> = std::pair&lt;A, B&gt;</td></tr>
<tr class="memdesc:a35750fd8bc2ddb9242180f4969595af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::pair&lt;T, S&gt; alias. <br /></td></tr>
<tr class="memitem:a61cddf44fce3cadb8711f6737c08c8d4" id="r_a61cddf44fce3cadb8711f6737c08c8d4"><td class="memTemplParams" colspan="2">template&lt;typename T, usize length&gt; </td></tr>
<tr class="memitem:a61cddf44fce3cadb8711f6737c08c8d4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61cddf44fce3cadb8711f6737c08c8d4">SizedArray</a> = std::array&lt;T, length&gt;</td></tr>
<tr class="memdesc:a61cddf44fce3cadb8711f6737c08c8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for std::array.  <br /></td></tr>
<tr class="memitem:ae748f37e7c306294bb4b39d6c2d2f216" id="r_ae748f37e7c306294bb4b39d6c2d2f216"><td class="memTemplParams" colspan="2"><a id="ae748f37e7c306294bb4b39d6c2d2f216" name="ae748f37e7c306294bb4b39d6c2d2f216"></a>
template&lt;typename T, usize length = std::dynamic_extent&gt; </td></tr>
<tr class="memitem:ae748f37e7c306294bb4b39d6c2d2f216 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><b>Span</b> = std::span&lt;T, length&gt;</td></tr>
<tr class="memdesc:ae748f37e7c306294bb4b39d6c2d2f216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction over any contiguous sequence of elements. <br /></td></tr>
<tr class="memitem:a2a24e330d12bcf0d832aeb83ed0b8769" id="r_a2a24e330d12bcf0d832aeb83ed0b8769"><td class="memItemLeft" align="right" valign="top"><a id="a2a24e330d12bcf0d832aeb83ed0b8769" name="a2a24e330d12bcf0d832aeb83ed0b8769"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>String</b> = std::string</td></tr>
<tr class="memdesc:a2a24e330d12bcf0d832aeb83ed0b8769"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::string, fat pointer to a heap allocated string <br /></td></tr>
<tr class="memitem:aa9888d477dbb8ea97e210df590b2319a" id="r_aa9888d477dbb8ea97e210df590b2319a"><td class="memItemLeft" align="right" valign="top"><a id="aa9888d477dbb8ea97e210df590b2319a" name="aa9888d477dbb8ea97e210df590b2319a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>widechar</b> = wchar_t</td></tr>
<tr class="memdesc:aa9888d477dbb8ea97e210df590b2319a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF Encoded Character. <br /></td></tr>
<tr class="memitem:a9fcc98917f6ecbde97036452377154c2" id="r_a9fcc98917f6ecbde97036452377154c2"><td class="memItemLeft" align="right" valign="top"><a id="a9fcc98917f6ecbde97036452377154c2" name="a9fcc98917f6ecbde97036452377154c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WideString</b> = std::wstring</td></tr>
<tr class="memdesc:a9fcc98917f6ecbde97036452377154c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::wstring, fat pointer to a heap allocated unicode string <br /></td></tr>
<tr class="memitem:a89add1f5bfc6b023426a419ba3bcdba8" id="r_a89add1f5bfc6b023426a419ba3bcdba8"><td class="memItemLeft" align="right" valign="top"><a id="a89add1f5bfc6b023426a419ba3bcdba8" name="a89add1f5bfc6b023426a419ba3bcdba8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringView</b> = std::string_view</td></tr>
<tr class="memdesc:a89add1f5bfc6b023426a419ba3bcdba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction over any contiguous sequence of characters, always prefer this over const <a class="el" href="#a2a24e330d12bcf0d832aeb83ed0b8769" title="std::string, fat pointer to a heap allocated string">String</a>&amp;. <br /></td></tr>
<tr class="memitem:a353dd0aad1745a3d4f951eb8418afd2a" id="r_a353dd0aad1745a3d4f951eb8418afd2a"><td class="memItemLeft" align="right" valign="top"><a id="a353dd0aad1745a3d4f951eb8418afd2a" name="a353dd0aad1745a3d4f951eb8418afd2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WideStringView</b> = std::wstring_view</td></tr>
<tr class="memdesc:a353dd0aad1745a3d4f951eb8418afd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction over any contiguous sequence of unicode characters, always prefer this over const <a class="el" href="#a9fcc98917f6ecbde97036452377154c2" title="std::wstring, fat pointer to a heap allocated unicode string">WideString</a>&amp;. <br /></td></tr>
<tr class="memitem:a4564c106afa8bd1d639610cda0222413" id="r_a4564c106afa8bd1d639610cda0222413"><td class="memItemLeft" align="right" valign="top"><a id="a4564c106afa8bd1d639610cda0222413" name="a4564c106afa8bd1d639610cda0222413"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringStream</b> = std::stringstream</td></tr>
<tr class="memdesc:a4564c106afa8bd1d639610cda0222413"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::stringstream <br /></td></tr>
<tr class="memitem:afbe677b189a53e80b8218c9c4c9fa564" id="r_afbe677b189a53e80b8218c9c4c9fa564"><td class="memItemLeft" align="right" valign="top"><a id="afbe677b189a53e80b8218c9c4c9fa564" name="afbe677b189a53e80b8218c9c4c9fa564"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OutStringStream</b> = std::ostringstream</td></tr>
<tr class="memdesc:afbe677b189a53e80b8218c9c4c9fa564"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::stringstream <br /></td></tr>
<tr class="memitem:a4c8692a5fda15b9b5cf7d9cd78f52806" id="r_a4c8692a5fda15b9b5cf7d9cd78f52806"><td class="memItemLeft" align="right" valign="top"><a id="a4c8692a5fda15b9b5cf7d9cd78f52806" name="a4c8692a5fda15b9b5cf7d9cd78f52806"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>InStringStream</b> = std::istringstream</td></tr>
<tr class="memdesc:a4c8692a5fda15b9b5cf7d9cd78f52806"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::stringstream <br /></td></tr>
<tr class="memitem:a04bb57ef8054e33e14b1212222b8c9b3" id="r_a04bb57ef8054e33e14b1212222b8c9b3"><td class="memItemLeft" align="right" valign="top"><a id="a04bb57ef8054e33e14b1212222b8c9b3" name="a04bb57ef8054e33e14b1212222b8c9b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>WideStringStream</b> = std::wstringstream</td></tr>
<tr class="memdesc:a04bb57ef8054e33e14b1212222b8c9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::wstringstream <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad7e153c092a68e53eabaa0e84a93a7ef" id="r_ad7e153c092a68e53eabaa0e84a93a7ef"><td class="memTemplParams" colspan="2"><a id="ad7e153c092a68e53eabaa0e84a93a7ef" name="ad7e153c092a68e53eabaa0e84a93a7ef"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad7e153c092a68e53eabaa0e84a93a7ef template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>builtin_to_string</b> (T &amp;&amp;obj) -&gt; <a class="el" href="#a2a24e330d12bcf0d832aeb83ed0b8769">String</a></td></tr>
<tr class="memitem:ab3be6d8e7f806dff323502e3da5ae5b1" id="r_ab3be6d8e7f806dff323502e3da5ae5b1"><td class="memTemplParams" colspan="2"><a id="ab3be6d8e7f806dff323502e3da5ae5b1" name="ab3be6d8e7f806dff323502e3da5ae5b1"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab3be6d8e7f806dff323502e3da5ae5b1 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (T &amp;&amp;obj) -&gt; <a class="el" href="#a2a24e330d12bcf0d832aeb83ed0b8769">String</a></td></tr>
<tr class="memitem:a76e77acae4267338001f6cbfd3636a57" id="r_a76e77acae4267338001f6cbfd3636a57"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e77acae4267338001f6cbfd3636a57">discard</a> (auto &amp;&amp;...) -&gt; <a class="el" href="structcrab_1_1unit.html">unit</a></td></tr>
<tr class="memitem:aec863eb47bbcc3d57ee9440a43d14f92" id="r_aec863eb47bbcc3d57ee9440a43d14f92"><td class="memItemLeft" align="right" valign="top"><a id="aec863eb47bbcc3d57ee9440a43d14f92" name="aec863eb47bbcc3d57ee9440a43d14f92"></a>
CRAB_INLINE auto&#160;</td><td class="memItemRight" valign="bottom"><b>unreachable</b> () -&gt; void</td></tr>
<tr class="memdesc:aec863eb47bbcc3d57ee9440a43d14f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes unreachable paths This should be used for optimisation purposes only. <br /></td></tr>
<tr class="memitem:afce5c7ce255c9a37e68477f43bb3bf5c" id="r_afce5c7ce255c9a37e68477f43bb3bf5c"><td class="memTemplParams" colspan="2"><a id="afce5c7ce255c9a37e68477f43bb3bf5c" name="afce5c7ce255c9a37e68477f43bb3bf5c"></a>
template&lt;ty::hashable T&gt; </td></tr>
<tr class="memitem:afce5c7ce255c9a37e68477f43bb3bf5c template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (const T &amp;value) -&gt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a></td></tr>
<tr class="memitem:a56eb8db8659b2407562e550fb56f65cf" id="r_a56eb8db8659b2407562e550fb56f65cf"><td class="memItemLeft" align="right" valign="top"><a id="a56eb8db8659b2407562e550fb56f65cf" name="a56eb8db8659b2407562e550fb56f65cf"></a>
CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hash_code_mix</b> (const <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a> seed, const <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a> next) -&gt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a></td></tr>
<tr class="memitem:add375536474f3a8706a16e9c12b5a3d1" id="r_add375536474f3a8706a16e9c12b5a3d1"><td class="memItemLeft" align="right" valign="top"><a id="add375536474f3a8706a16e9c12b5a3d1" name="add375536474f3a8706a16e9c12b5a3d1"></a>
CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hash_code_mix</b> (std::initializer_list&lt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a> &gt; list) -&gt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a></td></tr>
<tr class="memitem:aed116f3191a88efb50fb388aeeab923a" id="r_aed116f3191a88efb50fb388aeeab923a"><td class="memTemplParams" colspan="2"><a id="aed116f3191a88efb50fb388aeeab923a" name="aed116f3191a88efb50fb388aeeab923a"></a>
template&lt;into_hash_code... Ts&gt; </td></tr>
<tr class="memitem:aed116f3191a88efb50fb388aeeab923a template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hash_code_mix</b> (const Ts &amp;... values) -&gt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a></td></tr>
<tr class="memitem:a304f7c2073bf2e7fadae49d33d75c22e" id="r_a304f7c2073bf2e7fadae49d33d75c22e"><td class="memTemplParams" colspan="2"><a id="a304f7c2073bf2e7fadae49d33d75c22e" name="a304f7c2073bf2e7fadae49d33d75c22e"></a>
template&lt;ty::hashable... T&gt; </td></tr>
<tr class="memitem:a304f7c2073bf2e7fadae49d33d75c22e template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>hash_together</b> (const T &amp;... items) -&gt; <a class="el" href="#a65ead1c2bd0728e07b20e8b6c843b0aa">hash_code</a></td></tr>
<tr class="memitem:ad097b3489376c2c8f8b68415b97f78da" id="r_ad097b3489376c2c8f8b68415b97f78da"><td class="memTemplParams" colspan="2"><a id="ad097b3489376c2c8f8b68415b97f78da" name="ad097b3489376c2c8f8b68415b97f78da"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad097b3489376c2c8f8b68415b97f78da template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>forward</b> (ty::remove_reference&lt; T &gt; &amp;value) -&gt; T &amp;&amp;</td></tr>
<tr class="memitem:a1a30db6f5226807c6ff6a31eb26f3114" id="r_a1a30db6f5226807c6ff6a31eb26f3114"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1a30db6f5226807c6ff6a31eb26f3114 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a30db6f5226807c6ff6a31eb26f3114">move</a> (const T &amp;&amp;value)=delete</td></tr>
<tr class="memitem:ab5f803b5de4832a0cbc44dda59613018" id="r_ab5f803b5de4832a0cbc44dda59613018"><td class="memTemplParams" colspan="2">template&lt;ty::provider F&gt; </td></tr>
<tr class="memitem:ab5f803b5de4832a0cbc44dda59613018 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f803b5de4832a0cbc44dda59613018">then</a> (const bool cond, F &amp;&amp;func)</td></tr>
<tr class="memitem:a427446e6090b13dc5991678f49a40a59" id="r_a427446e6090b13dc5991678f49a40a59"><td class="memTemplParams" colspan="2">template&lt;ty::provider F&gt; </td></tr>
<tr class="memitem:a427446e6090b13dc5991678f49a40a59 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a427446e6090b13dc5991678f49a40a59">unless</a> (const bool cond, F &amp;&amp;func)</td></tr>
<tr class="memitem:aeced529d7fb6b9fd214bf9d4253d7b1e" id="r_aeced529d7fb6b9fd214bf9d4253d7b1e"><td class="memTemplParams" colspan="2"><a id="aeced529d7fb6b9fd214bf9d4253d7b1e" name="aeced529d7fb6b9fd214bf9d4253d7b1e"></a>
template&lt;typename... F&gt; </td></tr>
<tr class="memitem:aeced529d7fb6b9fd214bf9d4253d7b1e template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>fallible</b> (F &amp;&amp;... fallible)</td></tr>
<tr class="memitem:ac92e710dd0ef7e47a066edc8717c1810" id="r_ac92e710dd0ef7e47a066edc8717c1810"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac92e710dd0ef7e47a066edc8717c1810 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92e710dd0ef7e47a066edc8717c1810">some</a> (ty::identity&lt; T &gt; &amp;&amp;from)</td></tr>
<tr class="memitem:ad4c45b5257879e008cc5748bc2c3dc0c" id="r_ad4c45b5257879e008cc5748bc2c3dc0c"><td class="memTemplParams" colspan="2"><a id="ad4c45b5257879e008cc5748bc2c3dc0c" name="ad4c45b5257879e008cc5748bc2c3dc0c"></a>
template&lt;ty::non_const T, typename... Args&gt; </td></tr>
<tr class="memitem:ad4c45b5257879e008cc5748bc2c3dc0c template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>make_rc</b> (Args &amp;&amp;... args) -&gt; <a class="el" href="classcrab_1_1prelude_1_1Rc.html">Rc</a>&lt; T &gt;</td></tr>
<tr class="memitem:acb229115c7504de90b66dc28c1675d92" id="r_acb229115c7504de90b66dc28c1675d92"><td class="memTemplParams" colspan="2"><a id="acb229115c7504de90b66dc28c1675d92" name="acb229115c7504de90b66dc28c1675d92"></a>
template&lt;ty::non_const T, typename... Args&gt; <br />
requires std::constructible_from&lt;T, Args...&gt;</td></tr>
<tr class="memitem:acb229115c7504de90b66dc28c1675d92 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>make_rc_mut</b> (Args &amp;&amp;... args) -&gt; <a class="el" href="classcrab_1_1prelude_1_1RcMut.html">RcMut</a>&lt; T &gt;</td></tr>
<tr class="memitem:af0fe7a8af2b862b0ca7b11ca66dc99d1" id="r_af0fe7a8af2b862b0ca7b11ca66dc99d1"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af0fe7a8af2b862b0ca7b11ca66dc99d1 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0fe7a8af2b862b0ca7b11ca66dc99d1">implicit_cast</a> (ty::identity&lt; T &gt; type) noexcept(std::is_nothrow_move_constructible_v&lt; T &gt;) -&gt; decltype(auto)</td></tr>
<tr class="memitem:aafee25dba1636983099db50d95490aef" id="r_aafee25dba1636983099db50d95490aef"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aafee25dba1636983099db50d95490aef template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafee25dba1636983099db50d95490aef">is_exact</a> (const auto &amp;obj) noexcept -&gt; bool</td></tr>
<tr class="memdesc:aafee25dba1636983099db50d95490aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this given parameter <em>exactly</em> this type.  <br /></td></tr>
<tr class="memitem:aefb43f6a24582ca0e03fde71e1a2ac32" id="r_aefb43f6a24582ca0e03fde71e1a2ac32"><td class="memTemplParams" colspan="2"><a id="aefb43f6a24582ca0e03fde71e1a2ac32" name="aefb43f6a24582ca0e03fde71e1a2ac32"></a>
template&lt;error_type E, typename... Args&gt; </td></tr>
<tr class="memitem:aefb43f6a24582ca0e03fde71e1a2ac32 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>err</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memitem:a2b76458103cdd39cf3a52152f99b6435" id="r_a2b76458103cdd39cf3a52152f99b6435"><td class="memTemplParams" colspan="2"><a id="a2b76458103cdd39cf3a52152f99b6435" name="a2b76458103cdd39cf3a52152f99b6435"></a>
template&lt;ok_type T, typename... Args&gt; </td></tr>
<tr class="memitem:a2b76458103cdd39cf3a52152f99b6435 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>ok</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memitem:a542977cd7ffc9f9bdd59427072b8506a" id="r_a542977cd7ffc9f9bdd59427072b8506a"><td class="memTemplParams" colspan="2"><a id="a542977cd7ffc9f9bdd59427072b8506a" name="a542977cd7ffc9f9bdd59427072b8506a"></a>
template&lt;error_type E, std::invocable... F&gt; </td></tr>
<tr class="memitem:a542977cd7ffc9f9bdd59427072b8506a template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>fallible</b> (F &amp;&amp;... fallible)</td></tr>
<tr class="memitem:a5c0f98705440da51c938ae9ef26d12a0" id="r_a5c0f98705440da51c938ae9ef26d12a0"><td class="memTemplParams" colspan="2"><a id="a5c0f98705440da51c938ae9ef26d12a0" name="a5c0f98705440da51c938ae9ef26d12a0"></a>
template&lt;typename T, typename E&gt; </td></tr>
<tr class="memitem:a5c0f98705440da51c938ae9ef26d12a0 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>unwrap</b> (Result&lt; T, E &gt; &amp;&amp;result, const <a class="el" href="#af2eac98f50d89da93b0e8d20245479de">SourceLocation</a> loc=SourceLocation::current()) -&gt; T</td></tr>
<tr class="memitem:a07ddc105640bcd5b50ce472889327c30" id="r_a07ddc105640bcd5b50ce472889327c30"><td class="memTemplParams" colspan="2"><a id="a07ddc105640bcd5b50ce472889327c30" name="a07ddc105640bcd5b50ce472889327c30"></a>
template&lt;typename T, typename E&gt; </td></tr>
<tr class="memitem:a07ddc105640bcd5b50ce472889327c30 template"><td class="memItemLeft" align="right" valign="top">CRAB_INLINE constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>unwrap_err</b> (Result&lt; T, E &gt; &amp;&amp;result, const <a class="el" href="#af2eac98f50d89da93b0e8d20245479de">SourceLocation</a> loc=SourceLocation::current()) -&gt; E</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Created by Kishan Patel (<a href="#" onclick="location.href='mai'+'lto:'+'bis'+'ha'+'n.b'+'at'+'el@'+'pr'+'oto'+'nm'+'ail'+'.c'+'om'; return false;">bisha<span class="obfuscator">.nosp@m.</span>n.ba<span class="obfuscator">.nosp@m.</span>tel@p<span class="obfuscator">.nosp@m.</span>roto<span class="obfuscator">.nosp@m.</span>nmail<span class="obfuscator">.nosp@m.</span>.com</a>) on 3/3/2024 </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a446b4e5f093d488ef0d55e43c0736f51" name="a446b4e5f093d488ef0d55e43c0736f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446b4e5f093d488ef0d55e43c0736f51">&#9670;&#160;</a></span>Func</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F = void()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a446b4e5f093d488ef0d55e43c0736f51">crab::Func</a> = std::function&lt;F&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Alias) Functor wrapper </p>

</div>
</div>
<a id="a61cddf44fce3cadb8711f6737c08c8d4" name="a61cddf44fce3cadb8711f6737c08c8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cddf44fce3cadb8711f6737c08c8d4">&#9670;&#160;</a></span>SizedArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, usize length&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a61cddf44fce3cadb8711f6737c08c8d4">crab::SizedArray</a> = std::array&lt;T, length&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for std::array. </p>
<p>Statically Sized list of packed objects</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2eac98f50d89da93b0e8d20245479de" name="af2eac98f50d89da93b0e8d20245479de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2eac98f50d89da93b0e8d20245479de">&#9670;&#160;</a></span>SourceLocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af2eac98f50d89da93b0e8d20245479de">crab::SourceLocation</a> = std::source_location</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for std::source_location </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a76e77acae4267338001f6cbfd3636a57" name="a76e77acae4267338001f6cbfd3636a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e77acae4267338001f6cbfd3636a57">&#9670;&#160;</a></span>discard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::discard </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="structcrab_1_1unit.html">unit</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to discard / explicitly ignore certain outputs</p>
<p>This returns unit in the case of in templated contexts you want this variadic to be assigned to something. </p>

</div>
</div>
<a id="af0fe7a8af2b862b0ca7b11ca66dc99d1" name="af0fe7a8af2b862b0ca7b11ca66dc99d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fe7a8af2b862b0ca7b11ca66dc99d1">&#9670;&#160;</a></span>implicit_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::ref::implicit_cast </td>
          <td>(</td>
          <td class="paramtype">ty::identity&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td> -&gt; decltype(auto) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Explicit way of coercing a value to implicitly cast to a type rather than using static_cast </p>

</div>
</div>
<a id="aafee25dba1636983099db50d95490aef" name="aafee25dba1636983099db50d95490aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafee25dba1636983099db50d95490aef">&#9670;&#160;</a></span>is_exact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::ref::is_exact </td>
          <td>(</td>
          <td class="paramtype">const auto &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this given parameter <em>exactly</em> this type. </p>
<p>This will not perform a recursive check like dynamic_cast</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>B: <span class="keyword">public</span> A {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>C: <span class="keyword">public</span> B {};</div>
<div class="line"> </div>
<div class="line">i32 main() {</div>
<div class="line">  A a;</div>
<div class="line">  B b;</div>
<div class="line"> </div>
<div class="line">  debug_assert(crab::ref::is_exact&lt;A&gt;(a),<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  debug_assert(crab::ref::is_exact&lt;B&gt;(b),<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  debug_assert(crab::ref::is&lt;A&gt;(c),<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  debug_assert(not crab::ref::is_exact&lt;A&gt;(c),<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1a30db6f5226807c6ff6a31eb26f3114" name="a1a30db6f5226807c6ff6a31eb26f3114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a30db6f5226807c6ff6a31eb26f3114">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::mem::move </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to std::move with the added constraint of not being able to move from const, which is almost always a bug </p>

</div>
</div>
<a id="ac92e710dd0ef7e47a066edc8717c1810" name="ac92e710dd0ef7e47a066edc8717c1810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92e710dd0ef7e47a066edc8717c1810">&#9670;&#160;</a></span>some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::opt::some </td>
          <td>(</td>
          <td class="paramtype">ty::identity&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an Option&lt;T&gt; from some value T </p>

</div>
</div>
<a id="ab5f803b5de4832a0cbc44dda59613018" name="ab5f803b5de4832a0cbc44dda59613018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f803b5de4832a0cbc44dda59613018">&#9670;&#160;</a></span>then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ty::provider F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::opt::then </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a boolean to an option if it is true </p>

</div>
</div>
<a id="a427446e6090b13dc5991678f49a40a59" name="a427446e6090b13dc5991678f49a40a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427446e6090b13dc5991678f49a40a59">&#9670;&#160;</a></span>unless()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ty::provider F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CRAB_INLINE constexpr auto crab::opt::unless </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a boolean to an option if it is false </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacecrab.html">crab</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
